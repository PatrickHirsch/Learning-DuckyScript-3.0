REM Title: Ducky Cave
REM Author: Patrick Hirsch <HirschP2@nku.edu>
REM Description: Project from USB Rubber Ducky: Keystroke Injection Attacks with Advanced DuckyScript, a 'Game of Skill' in which a player uses CapsLock to navigates a cave of varying size without hitting the walls.
REM Game being replicated: https://github.com/hak5/usbrubberducky-payloads/blob/master/payloads/library/general/DuckyCave-Game/payload.txt

EXTENSION TRANSLATE
    REM VERSION 1.1
    REM AUTHOR: Korben

    REM_BLOCK DOCUMENTATION
        This extension acts as a library or collection of helper functions
        to work with converting variables in your payloads.
        WHY:
            Of the many ways to get information about the state of your payload
            is by injecting static strings effectively as debugging prints
            However, given the non-static nature of payloads using variables in
            DuckyScript 3.0 - the ability to decode variables during payload
            execution and print (inject) representations of their current state
            can often be a critically helpful development and debugging tool.

        Available Functions:
            DEFAULT:
                TRANSLATE_INT() - var to decimal string - set $INPUT prior to call
            EXTENDED: (enabled using the #INCLUDE defines below):
                TRANSLATE_HEX() - var to hexidecimal string - set $INPUT prior to call
                TRANSLATE_BINARY() - var to binary string - set $INPUT prior to call
                TRANSLATE_BOOL() - var to boolean string - set $INPUT prior to call

        USAGE:
            set $INPUT to desired var
            call the correct translate_ function for the expected data type e.g.
               VAR $myVar = 1234
               $INPUT = $myVar
               TRANSLATE_INT()
               REM the above code will inject 1234
    END_REM

    REM CONFIGURATION:
    DEFINE #INCLUDE_TRANSLATE_HEX FALSE
    DEFINE #INCLUDE_TRANSLATE_BOOL FALSE
    DEFINE #INCLUDE_TRANSLATE_BINARY FALSE
    DEFINE #INCLUDE_SWAP_ENDIAN FALSE

    REM Append ENTER after translation
    VAR $AS_STRINGLN = TRUE

    DEFINE #PRINT_INT 0
    DEFINE #PRINT_HEX 1
    VAR $DIGIT_PRINT_MODE = #PRINT_INT
    VAR $D = 0
    VAR $IN = 0
    VAR $INPUT = 0
    VAR $MOD = 0
    VAR $P = FALSE

    REM REQUIRED for INT/HEX - convert int to char
    FUNCTION PRINTDIGIT()
        IF ($D == 0) THEN
            STRING 0
        ELSE IF ($D == 1) THEN
            STRING 1
        ELSE IF ($D == 2) THEN
            STRING 2
        ELSE IF ($D == 3) THEN
            STRING 3
        ELSE IF ($D == 4) THEN
            STRING 4
        ELSE IF ($D == 5) THEN
            STRING 5
        ELSE IF ($D == 6) THEN
            STRING 6
        ELSE IF ($D == 7) THEN
            STRING 7
        ELSE IF ($D == 8) THEN
            STRING 8
        ELSE IF ($D == 9) THEN
            STRING 9
        IF_DEFINED_TRUE #INCLUDE_TRANSLATE_HEX
            ELSE IF ($DIGIT_PRINT_MODE == #PRINT_HEX) THEN
                IF ($D == 10) THEN
                    STRING A
                ELSE IF ($D == 11) THEN
                    STRING B
                ELSE IF ($D == 12) THEN
                    STRING C
                ELSE IF ($D == 13) THEN
                    STRING D
                ELSE IF ($D == 14) THEN
                    STRING E
                ELSE IF ($D == 15) THEN
                    STRING F
                END_IF
        END_IF_DEFINED
        ELSE
            STRING ?
        END_IF
    END_FUNCTION

    REM REQUIRED for INT/HEX- consumes a character / place from the input
    FUNCTION CONSUME()
        $D = 0
        WHILE ($INPUT >= $MOD)
            $D = ($D + 1)
            $INPUT = ($INPUT - $MOD)
        END_WHILE
        IF (($D > 0) || ($P == TRUE)) THEN
            $P = TRUE
            PRINTDIGIT()
        END_IF
    END_FUNCTION

    IF_DEFINED_TRUE #INCLUDE_SWAP_ENDIAN
        REM ENDIAN SWAPPER helper, (useful for working with VID/PID)
        FUNCTION SWAP_ENDIAN()
            $INPUT = ((($INPUT >> 8) & 0x00FF) | (($INPUT << 8) & 0xFF00))
        END_FUNCTION
    END_IF_DEFINED


    REM Translates a variable of presumed integer type and attempts to convert
    REM and inject a DECIMAL string representation
    FUNCTION TRANSLATE_INT() 
        $DIGIT_PRINT_MODE = #PRINT_INT
        $P = FALSE
        IF ( $INPUT >= 10000) THEN
            $MOD = 10000
            CONSUME()
        END_IF
        IF (($INPUT >= 1000) || ($P == TRUE)) THEN
            $MOD = 1000
            CONSUME()
        END_IF
        IF (($INPUT >= 100) || ($P == TRUE)) THEN
            $MOD = 100
            CONSUME()
        END_IF
        IF (($INPUT >= 10) || ($P == TRUE)) THEN
            $MOD = 10
            CONSUME()
        END_IF()
        $D = $INPUT
        PRINTDIGIT()
        IF $AS_STRINGLN THEN
            ENTER
        END_IF
    END_FUNCTION

    REM Translates a variable of presumed boolean type and attempts to convert
    REM and inject a BOOLEAN string representation
    REM TO ENABLE SET INCLUDE_TRANSLATE_BOOL to TRUE before compiling
    IF_DEFINED_TRUE #INCLUDE_TRANSLATE_BOOL
        FUNCTION TRANSLATE_BOOL()
            IF $INPUT THEN
                STRING TRUE
            ELSE
                STRING FALSE
            END_IF
            IF $AS_STRINGLN THEN
                ENTER
            END_IF
        END_FUNCTION
    END_IF_DEFINED

    REM Translates a variable of presumed integer type and attempts to convert
    REM and inject a HEX string representation
    REM TO ENABLE SET INCLUDE_TRANSLATE_HEX to TRUE before compiling
    IF_DEFINED_TRUE #INCLUDE_TRANSLATE_HEX
        FUNCTION TRANSLATE_HEX()
            $DIGIT_PRINT_MODE = #PRINT_HEX
            VAR $chars = 0
            VAR $d1 = 0
            VAR $d2 = 0
            VAR $d3 = 0
            VAR $d4 = 0
            WHILE ($INPUT > 0)
                IF ($chars == 0) THEN
                    $d1 = ($INPUT % 16)
                ELSE IF ($chars == 1) THEN
                    $d2 = ($INPUT % 16)
                ELSE IF ($chars == 2) THEN
                    $d3 = ($INPUT % 16)
                ELSE IF ($chars == 3) THEN
                    $d4 = ($INPUT % 16)
                END_IF
                $chars = ($chars + 1)
                $INPUT = ($INPUT / 16)
            END_WHILE
            VAR $i = 0
            STRING 0x
            IF ($chars == 0) THEN
                STRING 0x0000
            ELSE IF ($chars == 1) THEN
                STRING 000
                $D = $d1
                PRINTDIGIT()
            ELSE IF ($chars == 2) THEN
                STRING 00
                $D = $d2
                PRINTDIGIT()
                $D = $d1
                PRINTDIGIT()
            ELSE IF ($chars == 3) THEN
                STRING 0
                $D = $d3
                PRINTDIGIT()
                $D = $d2
                PRINTDIGIT()
                $D = $d1
                PRINTDIGIT()
            ELSE IF ($chars == 4) THEN
                STRING 0
                $D = $d4
                PRINTDIGIT()
                $D = $d3
                PRINTDIGIT()
                $D = $d2
                PRINTDIGIT()
                $D = $d1
                PRINTDIGIT()
            END_IF
            IF $AS_STRINGLN THEN
                ENTER
            END_IF
        END_FUNCTION
    END_IF_DEFINED

    REM Translates a variable of presumed integer type and attempts to convert
    REM and inject a BINARY string representation
    REM TO ENABLE SET INCLUDE_TRANSLATE_BINARY to TRUE before compiling
    IF_DEFINED_TRUE #INCLUDE_TRANSLATE_BINARY
        FUNCTION TRANSLATE_BINARY()
            VAR $I = 16
            WHILE ( $I > 0 )
                $I = ($I - 1)
                IF (($INPUT & 0x8000) == 0 ) THEN
                    STRING 0
                ELSE
                    STRING 1
                END_IF
                $INPUT = ($INPUT << 1)
            END_WHILE
            IF $AS_STRINGLN THEN
                ENTER
            END_IF
        END_FUNCTION
    END_IF_DEFINED
END_EXTENSION


REM -------------------------------------------------- REM


DEFINE FULL_CAVE_SIZE 75

VAR $TIMER = 0
VAR $MOVES = 0
VAR $SCORE = 0
VAR $GAME_WALL_L = 0
VAR $GAME_WALL_R = 0
VAR $GAME_PLAYER = 0

REM Debug
FUNCTION debuger()
	$INPUT = $GAME_WALL_L
	TRANSLATE_INT()
	$INPUT = $GAME_WALL_R
	TRANSLATE_INT()
	$INPUT = $GAME_PLAYER
	TRANSLATE_INT()
END_FUNCTION

FUNCTION openNotepad()
	REM Open Notepad
	GUI r
	DELAY 100
	STRINGLN notepad
	DELAY 100
END_FUNCTION

REM Initialize
FUNCTION initialize()
	REM Initialize placers to reasonable starting locations
	$GAME_WALL_L = ( FULL_CAVE_SIZE / 4 )
	$GAME_WALL_R = ( FULL_CAVE_SIZE - $GAME_WALL_L )
	$GAME_PLAYER = ( FULL_CAVE_SIZE / 2 )
	
	REM Randomize the wall values a bit, vary them by Â± 1/16th of the game's width
	$_RANDOM_MIN = 0
	$_RANDOM_MAX = ( $GAME_WALL_L / 4 )
	IF ($_RANDOM_INT % 2) THEN
		$GAME_WALL_L = ( $GAME_WALL_L + $_RANDOM_INT )
	ELSE
		$GAME_WALL_L = ( $GAME_WALL_L - $_RANDOM_INT )
	END_IF
	IF ($_RANDOM_INT % 2) THEN
		$GAME_WALL_R = ( $GAME_WALL_R + $_RANDOM_INT )
	ELSE
		$GAME_WALL_R = ( $GAME_WALL_R - $_RANDOM_INT )
	END_IF

	REM Randomize Player location ensuring at least a 4 char distance from each wall
	$_RANDOM_MIN = ( $GAME_WALL_L + 4 )
	$_RANDOM_MAX = ( $GAME_WALL_R - 4 )
	$GAME_PLAYER = $_RANDOM_INT
	
	SAVE_HOST_KEYBOARD_LOCK_STATE
END_FUNCTION

REM Print layer
FUNCTION printCaveLayer()
	$TIMER = $GAME_WALL_L
	WHILE ( $TIMER > 1 )
		STRING  
		$TIMER = ( $TIMER - 1 )
	END_WHILE
	STRING |
	
	$TIMER = ($GAME_PLAYER - $GAME_WALL_L)
	WHILE ( $TIMER > 1 )
		STRING  
		$TIMER = ( $TIMER - 1 )
	END_WHILE
	
	IF $_CAPSLOCK_ON THEN
		STRING >
	ELSE
		STRING <
	END_IF
	
	$TIMER = ($GAME_WALL_R - $GAME_PLAYER)
	WHILE ( $TIMER > 1 )
		STRING  
		$TIMER = ( $TIMER - 1 )
	END_WHILE
	STRINGLN |
END_FUNCTION

FUNCTION endGame()
	$TIMER = $GAME_PLAYER
	WHILE ( $TIMER > 2 )
		STRING  
		$TIMER = ( $TIMER - 1 )
	END_WHILE
	STRINGLN BONK!
	ENTER
	
	STRING Left wall: 
	$INPUT = $GAME_WALL_L
	TRANSLATE_INT()
	
	STRING Right wall: 
	$INPUT = $GAME_WALL_R
	TRANSLATE_INT()
	
	STRING Player position: 
	$INPUT = $GAME_PLAYER
	TRANSLATE_INT()
	
	STRING Player Moves: 
	$INPUT = $MOVES
	TRANSLATE_INT()
	
	STRING Game over. score: 
	$INPUT = $SCORE
	TRANSLATE_INT()
	
	REM Replay?
	$inGame = FALSE
	ENTER
	ENTER
	STRINGLN Press CapsLock to play again
	WAIT_FOR_CAPS_CHANGE
	ALT F4
	RIGHT
	ENTER
	RESTART_PAYLOAD
END_FUNCTION

FUNCTION checkCollision()
	IF (( ($GAME_PLAYER+1) >= $GAME_WALL_R ) || ( ($GAME_PLAYER-1) <= $GAME_WALL_L )) THEN
		endGame()
	END_IF
END_FUNCTION

FUNCTION scoreingEngine()
	$SCORE = ($SCORE + 1)
	IF ( $_CAPSLOCK_ON != $_SAVED_CAPSLOCK_ON ) THEN
		$MOVES = ($MOVES+1)
	END_IF
	SAVE_HOST_KEYBOARD_LOCK_STATE
END_FUNCTION

FUNCTION playRound()
	IF $_CAPSLOCK_ON THEN
		$GAME_PLAYER = ( $GAME_PLAYER + 1 )
	ELSE
		$GAME_PLAYER = ( $GAME_PLAYER - 1 )
	END_IF
	scoreingEngine()
	
	$_RANDOM_MIN = 0
	$_RANDOM_MAX = 2
	IF ($_RANDOM_INT || ($GAME_WALL_L == 1)) THEN
		$GAME_WALL_L = ( $GAME_WALL_L + 1 )
	ELSE
		$GAME_WALL_L = ( $GAME_WALL_L - 1 )
	END_IF
	
	IF ($_RANDOM_INT || ($GAME_WALL_R == ( FULL_CAVE_SIZE - 1 ))) THEN
		$GAME_WALL_R = ( $GAME_WALL_R - 1 )
	ELSE
		$GAME_WALL_R = ( $GAME_WALL_R + 1 )
	END_IF
	
	checkCollision()
END_FUNCTION

REM -------------------------------------------------- REM

openNotepad()

WHILE TRUE
	REM Start Menu
	STRINGLN Welcome to Ducky Cave
	STRINGLN    as writen by Patrick Hirsch
	ENTER
	$TIMER = 5
	STRING Press CAPSLOCK 5 times to start.....
	WHILE ($TIMER)
		WAIT_FOR_CAPS_CHANGE
		BACKSPACE
		$TIMER = ( $TIMER - 1 )
	END_WHILE
	ENTER
	
	initialize()
	STRINGLN Starting!
	
	printCaveLayer()
	
	VAR $inGame = TRUE
	WHILE $inGame
		playRound()
		printCaveLayer()
		checkCollision()
	END_WHILE
END_WHILE
